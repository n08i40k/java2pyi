use crate::{ast, lexer};
use std::borrow::Cow;

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token<'input> {
        "=" => lexer::Token::Eq,
        "*" => lexer::Token::Multiply,
        "&" => lexer::Token::Ampersand,
        ":" => lexer::Token::Colon,
        ";" => lexer::Token::Semicolon,
        "," => lexer::Token::Comma,
        "." => lexer::Token::Period,
        "..." => lexer::Token::VarArg,

        "(" => lexer::Token::OpenPth,
        ")" => lexer::Token::ClosePth,
        "[" => lexer::Token::OpenBracket,
        "]" => lexer::Token::CloseBracket,
        "{" => lexer::Token::OpenBrace,
        "}" => lexer::Token::CloseBrace,
        "<" => lexer::Token::OpenAngle,
        ">" => lexer::Token::CloseAngle,
        "?" => lexer::Token::QuestionMark,

        Boolean => lexer::Token::Boolean(<bool>),
        Integer => lexer::Token::Integer(<i64>),

        "abstract" => lexer::Token::KeywordAbstract,
        "assert" => lexer::Token::KeywordAssert,
        "break" => lexer::Token::KeywordBreak,
        "case" => lexer::Token::KeywordCase,
        "catch" => lexer::Token::KeywordCatch,
        "class" => lexer::Token::KeywordClass,
        "continue" => lexer::Token::KeywordContinue,
        "const" => lexer::Token::KeywordConst,
        "default" => lexer::Token::KeywordDefault,
        "do" => lexer::Token::KeywordDo,
        "else" => lexer::Token::KeywordElse,
        "enum" => lexer::Token::KeywordEnum,
        "exports" => lexer::Token::KeywordExports,
        "extends" => lexer::Token::KeywordExtends,
        "final" => lexer::Token::KeywordFinal,
        "finally" => lexer::Token::KeywordFinally,
        "for" => lexer::Token::KeywordFor,
        "goto" => lexer::Token::KeywordGoto,
        "if" => lexer::Token::KeywordIf,
        "implements" => lexer::Token::KeywordImplements,
        "import" => lexer::Token::KeywordImport,
        "instanceof" => lexer::Token::KeywordInstanceof,
        "interface" => lexer::Token::KeywordInterface,
        "module" => lexer::Token::KeywordModule,
        "native" => lexer::Token::KeywordNative,
        "new" => lexer::Token::KeywordNew,
        "non-sealed" => lexer::Token::KeywordNonSealed,
        "package" => lexer::Token::KeywordPackage,
        "permits" => lexer::Token::KeywordPermits,
        "private" => lexer::Token::KeywordPrivate,
        "protected" => lexer::Token::KeywordProtected,
        "public" => lexer::Token::KeywordPublic,
        "record" => lexer::Token::KeywordRecord,
        "requires" => lexer::Token::KeywordRequires,
        "return" => lexer::Token::KeywordReturn,
        "sealed" => lexer::Token::KeywordSealed,
        "static" => lexer::Token::KeywordStatic,
        "strictfp" => lexer::Token::KeywordStrictfp,
        "super" => lexer::Token::KeywordSuper,
        "switch" => lexer::Token::KeywordSwitch,
        "synchronized" => lexer::Token::KeywordSynchronized,
        "this" => lexer::Token::KeywordThis,
        "throw" => lexer::Token::KeywordThrow,
        "throws" => lexer::Token::KeywordThrows,
        "transient" => lexer::Token::KeywordTransient,
        "try" => lexer::Token::KeywordTry,
        "var" => lexer::Token::KeywordVar,
        "volatile" => lexer::Token::KeywordVolatile,
        "while" => lexer::Token::KeywordWhile,

        "void" => lexer::Token::TypeVoid,
        "boolean" => lexer::Token::TypeBoolean,
        "byte" => lexer::Token::TypeByte,
        "char" => lexer::Token::TypeChar,
        "short" => lexer::Token::TypeShort,
        "int" => lexer::Token::TypeInt,
        "long" => lexer::Token::TypeLong,
        "float" => lexer::Token::TypeFloat,
        "double" => lexer::Token::TypeDouble,

        RecordCtor => lexer::Token::RecordCtor,

        String => lexer::Token::String(<Cow<'input, str>>),
        Ident => lexer::Token::Ident(<Cow<'input, str>>),
    }
}

#[inline]
UnsafeIdent: Cow<'input, str> = {
  <Ident> => <>,
  "module" => Cow::from("module"),
  "this" => Cow::from("this"),
  "record" => Cow::from("record"),
  "exports" => Cow::from("exports"),
  "requires" => Cow::from("requires"),
  "permits" => Cow::from("permits"),
};

#[inline]
Path: Cow<'input, str> = <l:@L> UnsafeIdent ("." UnsafeIdent)* <r:@R> => Cow::from(&input[l..r]);

CommaList<T>: Box<[T]> = <first:T> <mut rest:("," <T>)*> => { rest.insert(0, first); rest.into_boxed_slice() };
TrailingCommaList<T>: Box<[T]> = <first:T> <mut rest:("," <T>)*> "," => { rest.insert(0, first); rest.into_boxed_slice() };

OptionalSemicolonList<T>: Box<[T]> = <first:T> ";"* <mut rest:(<T> ";"*)*> => { rest.insert(0, first); rest.into_boxed_slice() };

MayBeTrailingCommaList<T>: Box<[T]> = {
  <CommaList<T>> => <>,
  <TrailingCommaList<T>> => <>,
};

AmpersandList<T>: Box<[T]> = <first:T> <mut rest:("&" <T>)*> => { rest.insert(0, first); rest.into_boxed_slice() };
PeriodList<T>: Box<[T]> = <first:T> <mut rest:("." <T>)*> => { rest.insert(0, first); rest.into_boxed_slice() };

Package: Cow<'input, str> = "package" <p:Path> ";" => p;

#[inline]
ImportPath: Cow<'input, str> = <l:@L> UnsafeIdent ("." UnsafeIdent)* ("." "*")? <r:@R> => Cow::from(&input[l..r]);
Import: Cow<'input, str> = "import" "static"? <p:ImportPath> ";" => p;

Modifier: ast::Modifiers = {
  "public" => ast::Modifiers::PUBLIC,
  "private" => ast::Modifiers::PRIVATE,
  "protected" => ast::Modifiers::PROTECTED,
  "static" => ast::Modifiers::STATIC,
  "final" => ast::Modifiers::FINAL,
  "sealed" => ast::Modifiers::SEALED,
  "non-sealed" => ast::Modifiers::NON_SEALED,
  "abstract" => ast::Modifiers::ABSTRACT,
  "native" => ast::Modifiers::NATIVE,
  "synchronized" => ast::Modifiers::SYNCHRONIZED,
  "transient" => ast::Modifiers::TRANSIENT,
  "volatile" => ast::Modifiers::VOLATILE,
  "strictfp" => ast::Modifiers::STRICTFP,
  "default" => ast::Modifiers::DEFAULT,
}

Modifiers: ast::Modifiers = <mods:Modifier*> => mods.into_iter().reduce(|a, b| a | b).unwrap_or(ast::Modifiers::empty());

TypeName: ast::TypeName = {
  "void" => ast::TypeName::Void,
  "boolean" => ast::TypeName::Boolean,
  "byte" => ast::TypeName::Byte,
  "char" => ast::TypeName::Char,
  "short" => ast::TypeName::Short,
  "int" => ast::TypeName::Integer,
  "long" => ast::TypeName::Long,
  "float" => ast::TypeName::Float,
  "double" => ast::TypeName::Double,
  <i:Ident> => ast::TypeName::Ident(i.to_string()),
};

TypeGeneric: ast::TypeGeneric = {
  <t:QualifiedType>               => ast::TypeGeneric::Type(t),
  "?"                             => ast::TypeGeneric::Wildcard(ast::WildcardBoundary::None),
  "?" "extends" <t:QualifiedType> => ast::TypeGeneric::Wildcard(ast::WildcardBoundary::Extends(t)),
  "?" "super" <t:QualifiedType>   => ast::TypeGeneric::Wildcard(ast::WildcardBoundary::Super(t)),
};

pub TypeGenerics: Box<[ast::TypeGeneric]> = "<" <l:CommaList<TypeGeneric>?> ">" => l.unwrap_or(Box::from([]));

Type: ast::Type 
  = <n:TypeName> <g:TypeGenerics?> <a:("[" "]")*>
  => ast::Type {
    name: n,
    generics: g.unwrap_or(Box::from([])),
    array_depth: a.len(),
  };

QualifiedType: ast::QualifiedType = PeriodList<Type> => <>;

#[inline]
UnsafeIdentWithArray: (Cow<'input, str>, usize) 
  = <i:UnsafeIdent> <a:("[" "]")*>
  => (i, a.len());

Variables: Box<[ast::Variable]> 
  = <m:Modifiers> <t:QualifiedType> <i:CommaList<UnsafeIdentWithArray>> ";" 
  => ast::Variable::new_array(m, t, i);

GenericDefinitionsExtends: Box<[ast::QualifiedType]> = "extends" <e:AmpersandList<QualifiedType>> => e;

GenericDefinition: ast::GenericDefinition
  = <i:Ident> <e:GenericDefinitionsExtends?>
  => ast::GenericDefinition { ident: i.to_string(), extends: e.unwrap_or(Box::new([])) };

GenericDefinitions: Box<[ast::GenericDefinition]>
  = "<" <g:CommaList<GenericDefinition>> ">"
  => g;

FunctionArgument: ast::FunctionArgument
  = <m:Modifiers> <mut t:QualifiedType> <v:"..."?> <i:UnsafeIdent> <a:("[" "]")*> 
  => ast::FunctionArgument {
    modifiers: m,
    r#type: { t.last_mut().unwrap().array_depth += a.len(); t },
    ident: i.to_string(),
    vararg: v.is_some(),
  };

#[inline]
FunctionEnd: () = { "{" "}", ";" };

Function: ast::Function
  = <m:Modifiers> <g:GenericDefinitions?> <rt:QualifiedType> <i:UnsafeIdent?> "(" <args:CommaList<FunctionArgument>?> ")" ("throws" CommaList<QualifiedType>)? FunctionEnd
  => ast::Function {
    modifiers: m,
    generics: g.unwrap_or(Box::from([])),
    return_type: rt,
    ident: i.unwrap_or_else(|| Cow::from("__ctor")).to_string(),
    arguments: args.unwrap_or(Box::from([]))
  };

InterfaceEntry: ast::InterfaceEntry = {
  <v:Variables> => ast::InterfaceEntry::Variables(v),
  <f:Function> => ast::InterfaceEntry::Function(f),
  <c:Class> => ast::InterfaceEntry::Class(c),
  <e:Enum> => ast::InterfaceEntry::Enum(e),
  <i:Interface> => ast::InterfaceEntry::Interface(i),
  "static"? "{" "}" => ast::InterfaceEntry::Skip,
  Modifiers RecordCtor "{" "}" => ast::InterfaceEntry::Skip,
};

#[inline]
ObjectPermits: Box<[ast::QualifiedType]> = "permits" <l:CommaList<QualifiedType>> => l;

#[inline]
InterfaceExtends: Box<[ast::QualifiedType]> = "extends" <t:CommaList<QualifiedType>> => t;

Interface: ast::Interface
  = <m:Modifiers> "interface" <i:Ident> <g:GenericDefinitions?> <ex:InterfaceExtends?> <p:ObjectPermits?> "{" <e:OptionalSemicolonList<InterfaceEntry>?> "}"
  => ast::Interface::from((m, i, g, ex, p, e));

#[inline]
ObjectImplements: Box<[ast::QualifiedType]> = "implements" <l:CommaList<QualifiedType>> => l;

ClassEntry: ast::ClassEntry = {
  <v:Variables> => ast::ClassEntry::Variables(v),
  <f:Function> => ast::ClassEntry::Function(f),
  <c:Class> => ast::ClassEntry::Class(c),
  <e:Enum> => ast::ClassEntry::Enum(e),
  <i:Interface> => ast::ClassEntry::Interface(i),
  "static"? "{" "}" => ast::ClassEntry::Skip,
  Modifiers RecordCtor "{" "}" => ast::ClassEntry::Skip,
};

#[inline]
ClassExtends: ast::QualifiedType = "extends" <t:QualifiedType> => t;

Class: ast::Class = {
  <m:Modifiers> "class" <i:Ident> <g:GenericDefinitions?> <ex:ClassExtends?> <im:ObjectImplements?> <p:ObjectPermits?> "{" <en:OptionalSemicolonList<ClassEntry>?> "}"
  => ast::Class::from((m, i, g, ex, im, p, en)),

  <m:Modifiers> "record" <i:Ident> <g:GenericDefinitions?> "(" <a:CommaList<FunctionArgument>?> ")" <im:ObjectImplements?> "{" <en:OptionalSemicolonList<ClassEntry>?> "}"
  => ast::Class::from((m, i, g, a, im, en)),
};

#[inline]
EnumVariant: () = Ident ("(" ")")? ("{" "}")?;

#[inline]
EnumEntry: ast::EnumEntry = {
  <v:Variables> => ast::EnumEntry::Variables(v),
  <f:Function> => ast::EnumEntry::Function(f),
  <c:Class> => ast::EnumEntry::Class(c),
  <e:Enum> => ast::EnumEntry::Enum(e),
  <i:Interface> => ast::EnumEntry::Interface(i),
  "static"? "{" "}" => ast::EnumEntry::Skip,
};

#[inline]
EnumBody: Box<[ast::EnumEntry]> = {
  MayBeTrailingCommaList<EnumVariant> ";"?             => Box::from([]),
  MayBeTrailingCommaList<EnumVariant> ";" <OptionalSemicolonList<EnumEntry>> => <>,
};

Enum: ast::Enum
  = <m:Modifiers> "enum" <i:Ident> <g:GenericDefinitions?> <im:ObjectImplements?> "{" <b:EnumBody?> "}"
  => ast::Enum::from((m, i, g, im, b));

RootEntry: ast::RootEntry = {
  <c:Class> => ast::RootEntry::Class(c),
  <e:Enum> => ast::RootEntry::Enum(e),
  <i:Interface> => ast::RootEntry::Interface(i),
};

pub Root: ast::Root
  = <p:Package> <i:Import*> <e:OptionalSemicolonList<RootEntry>?>
  => ast::Root::from((p, i, e));
