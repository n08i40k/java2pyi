use crate::{ast, lexer};
use std::borrow::Cow;

grammar<'input>(input: &'input str);

extern {
    type Location = usize;
    type Error = lexer::LexicalError;

    enum lexer::Token<'input> {
        "=" => lexer::Token::Eq,
        "*" => lexer::Token::Multiply,
        "&" => lexer::Token::Ampersand,
        ":" => lexer::Token::Colon,
        ";" => lexer::Token::Semicolon,
        "," => lexer::Token::Comma,
        "." => lexer::Token::Period,
        "..." => lexer::Token::VarArg,

        "(" => lexer::Token::OpenPth,
        ")" => lexer::Token::ClosePth,
        "[" => lexer::Token::OpenBracket,
        "]" => lexer::Token::CloseBracket,
        "{" => lexer::Token::OpenBrace,
        "}" => lexer::Token::CloseBrace,
        "<" => lexer::Token::OpenAngle,
        ">" => lexer::Token::CloseAngle,
        "?" => lexer::Token::QuestionMark,

        Boolean => lexer::Token::Boolean(<bool>),
        Integer => lexer::Token::Integer(<i64>),

        "abstract" => lexer::Token::KeywordAbstract,
        "assert" => lexer::Token::KeywordAssert,
        "break" => lexer::Token::KeywordBreak,
        "case" => lexer::Token::KeywordCase,
        "catch" => lexer::Token::KeywordCatch,
        "class" => lexer::Token::KeywordClass,
        "continue" => lexer::Token::KeywordContinue,
        "const" => lexer::Token::KeywordConst,
        "default" => lexer::Token::KeywordDefault,
        "do" => lexer::Token::KeywordDo,
        "else" => lexer::Token::KeywordElse,
        "enum" => lexer::Token::KeywordEnum,
        "exports" => lexer::Token::KeywordExports,
        "extends" => lexer::Token::KeywordExtends,
        "final" => lexer::Token::KeywordFinal,
        "finally" => lexer::Token::KeywordFinally,
        "for" => lexer::Token::KeywordFor,
        "goto" => lexer::Token::KeywordGoto,
        "if" => lexer::Token::KeywordIf,
        "implements" => lexer::Token::KeywordImplements,
        "import" => lexer::Token::KeywordImport,
        "instanceof" => lexer::Token::KeywordInstanceof,
        "interface" => lexer::Token::KeywordInterface,
        "module" => lexer::Token::KeywordModule,
        "native" => lexer::Token::KeywordNative,
        "new" => lexer::Token::KeywordNew,
        "package" => lexer::Token::KeywordPackage,
        "private" => lexer::Token::KeywordPrivate,
        "protected" => lexer::Token::KeywordProtected,
        "public" => lexer::Token::KeywordPublic,
        "requires" => lexer::Token::KeywordRequires,
        "return" => lexer::Token::KeywordReturn,
        "static" => lexer::Token::KeywordStatic,
        "strictfp" => lexer::Token::KeywordStrictfp,
        "super" => lexer::Token::KeywordSuper,
        "switch" => lexer::Token::KeywordSwitch,
        "synchronized" => lexer::Token::KeywordSynchronized,
        "this" => lexer::Token::KeywordThis,
        "throw" => lexer::Token::KeywordThrow,
        "throws" => lexer::Token::KeywordThrows,
        "transient" => lexer::Token::KeywordTransient,
        "try" => lexer::Token::KeywordTry,
        "var" => lexer::Token::KeywordVar,
        "volatile" => lexer::Token::KeywordVolatile,
        "while" => lexer::Token::KeywordWhile,

        "void" => lexer::Token::TypeVoid,
        "boolean" => lexer::Token::TypeBoolean,
        "char" => lexer::Token::TypeChar,
        "short" => lexer::Token::TypeShort,
        "int" => lexer::Token::TypeInt,
        "long" => lexer::Token::TypeLong,
        "float" => lexer::Token::TypeFloat,
        "double" => lexer::Token::TypeDouble,

        String => lexer::Token::String(<Cow<'input, str>>),
        Ident => lexer::Token::Ident(<Cow<'input, str>>),
    }
}

#[inline]
Path: Cow<'input, str> = <l:@L> Ident ("." Ident)* <r:@R> => Cow::from(&input[l..r]);

Package: Cow<'input, str> = "package" <p:Path> ";" => p;

#[inline]
ImportPath: Cow<'input, str> = <l:@L> Ident ("." Ident)* ("." "*")? <r:@R> => Cow::from(&input[l..r]);
Import: Cow<'input, str> = "import" "static"? <p:ImportPath> ";" => p;

Modifier: ast::Modifiers = {
  "public" => ast::Modifiers::PUBLIC,
  "private" => ast::Modifiers::PRIVATE,
  "protected" => ast::Modifiers::PROTECTED,
  "static" => ast::Modifiers::STATIC,
  "final" => ast::Modifiers::FINAL,       
  "abstract" => ast::Modifiers::ABSTRACT,    
  "native" => ast::Modifiers::NATIVE,      
  "synchronized" => ast::Modifiers::SYNCHRONIZED,
  "transient" => ast::Modifiers::TRANSIENT,   
  "volatile" => ast::Modifiers::VOLATILE,    
  "strictfp" => ast::Modifiers::STRICTFP,    
  "default" => ast::Modifiers::DEFAULT,    
}

Modifiers: ast::Modifiers = <mods:Modifier*> => mods.into_iter().reduce(|a, b| a | b).unwrap_or(ast::Modifiers::empty());

CommaList<T>: Box<[T]> = <first:T> <mut rest:("," <T>)*> => { rest.insert(0, first); rest.into_boxed_slice() };
AmpersandList<T>: Box<[T]> = <first:T> <mut rest:("&" <T>)*> => { rest.insert(0, first); rest.into_boxed_slice() };

TypeName: ast::TypeName = {
  "void" => ast::TypeName::Void,
  "boolean" => ast::TypeName::Boolean,
  "char" => ast::TypeName::Char,
  "short" => ast::TypeName::Short,
  "int" => ast::TypeName::Integer,
  "long" => ast::TypeName::Long,
  "float" => ast::TypeName::Float,
  "double" => ast::TypeName::Double,
  <i:Path> => ast::TypeName::Ident(i.to_string()),
};

TypeGeneric: ast::TypeGeneric = {
  <t:Type>                => ast::TypeGeneric::Type(t),
  "?"                     => ast::TypeGeneric::Wildcard(ast::WildcardBoundary::None),
  "?" "extends" <t:Type>  => ast::TypeGeneric::Wildcard(ast::WildcardBoundary::Extends(t)),
  "?" "super" <t:Type>    => ast::TypeGeneric::Wildcard(ast::WildcardBoundary::Super(t)),
};

TypeGenerics: Box<[ast::TypeGeneric]> = "<" <l:CommaList<TypeGeneric>?> ">" => l.unwrap_or(Box::from([]));

ArrayType: ast::Type = <mut t:Type> "[" "]" => { t.array = true; t };

Type: ast::Type = {
  <n:TypeName> <g:TypeGenerics?> => ast::Type {
    name: n,
    generics: g.unwrap_or(Box::from([])),
    array: false,
  },
  
  <t:ArrayType> => t,
};


Variables: Box<[ast::Variable]> 
  = <m:Modifiers> <t:Type> <i:CommaList<Ident>> ";" 
  => ast::Variable::new_array(m, t, i);

GenericDefinitionsExtends: Box<[ast::Type]> = "extends" <e:AmpersandList<Type>> => e;

GenericDefinition: ast::GenericDefinition
  = <i:Ident> <e:GenericDefinitionsExtends?>
  => ast::GenericDefinition { ident: i.to_string(), extends: e.unwrap_or(Box::new([])) };

GenericDefinitions: Box<[ast::GenericDefinition]>
  = "<" <g:CommaList<GenericDefinition>> ">"
  => g;

#[inline]
FunctionArgumentIdent: Cow<'input, str> = {
  Ident => <>,
  "this" => Cow::from("this"),
};
FunctionArgument: ast::FunctionArgument
  = <m:Modifiers> <t:Type> <v:"..."?> <i:Ident>
  = <m:Modifiers> <t:Type> <v:"..."?> <i:FunctionArgumentIdent>
  => ast::FunctionArgument {
    modifiers: m,
    r#type: t,
    ident: i.to_string(),
    vararg: v.is_some(),
  };

#[inline]
FunctionEnd: () = { "{" "}", ";" };

Function: ast::Function
  = <m:Modifiers> <g:GenericDefinitions?> <rt:Type> <i:Ident?> "(" <args:CommaList<FunctionArgument>?> ")" ("throws" CommaList<Type>)? FunctionEnd
  => ast::Function {
    modifiers: m,
    generics: g.unwrap_or(Box::from([])),
    return_type: rt,
    ident: i.unwrap_or_else(|| Cow::from("constructor")).to_string(),
    arguments: args.unwrap_or(Box::from([]))
  };

InterfaceEntry: ast::InterfaceEntry = {
  <v:Variables> => ast::InterfaceEntry::Variables(v),
  <f:Function> => ast::InterfaceEntry::Function(f),
  <c:Class> => ast::InterfaceEntry::Class(c),
  <i:Interface> => ast::InterfaceEntry::Interface(i),
};

#[inline]
InterfaceExtends: Box<[ast::Type]> = "extends" <t:CommaList<Type>> => t;

Interface: ast::Interface
  = <m:Modifiers> "interface" <i:Ident> <g:GenericDefinitions?> <ex:InterfaceExtends?> "{" <e:InterfaceEntry*> "}"
  => ast::Interface::from((m, i, g, ex, e));

ClassEntry: ast::ClassEntry = {
  <v:Variables> => ast::ClassEntry::Variables(v),
  <f:Function> => ast::ClassEntry::Function(f),
  <c:Class> => ast::ClassEntry::Class(c),
  <i:Interface> => ast::ClassEntry::Interface(i),
  "static" "{" "}" => ast::ClassEntry::Skip,
};

ClassImplements: Box<[ast::Type]> = "implements" <l:CommaList<Type>> => l;

#[inline]
ClassExtends: ast::Type = "extends" <t:Type> => t;

Class: ast::Class
  = <m:Modifiers> "class" <i:Ident> <g:GenericDefinitions?> <ex:ClassExtends?> <im:ClassImplements?> "{" <en:ClassEntry*> "}" ";"?
  => ast::Class::from((m, i, g, ex, im, en));


RootEntry: ast::RootEntry = {
  <c:Class> => ast::RootEntry::Class(c),
  <i:Interface> => ast::RootEntry::Interface(i),
};

pub Root: ast::Root
  = <p:Package> <i:Import*> <e:RootEntry*>
  => ast::Root::from((p, i, e));
